---
title: "Iris Data"
author: "Alan n. Inglis"
date: "`r Sys.Date()`"
output:
  pdf_document: default
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,  fig.width = 9, fig.height = 7, fig.align = "center", fig.path = "irisFigs/", fig.show='hold')
```


This script is to recreate FIGURES 2-10:


```{r, install_bartMan_from_GitHub}
# install.packages("devtools")
#devtools::install_github("AlanInglis/bartMan")
```


## Load libraries:

```{r load_libraries}
library(bartMachine) # for model
library(dbarts) # for model
library(bartMan) # for visualizations
library(ggplot2) # for visualizations
```

## Read in and setup data:

```{r load_data}
# load data
data(iris)
iris2 = iris[1:100,]
iris2$Species <- factor(iris2$Species)
iris2$Species <- ifelse(iris2$Species == "setosa", 0, 1)
```

## Build models

```{r build_model}
# bartMachine
set.seed(100)
bm <-  bartMachine(X = iris2[,1:4],
                   y = iris2[,5],
                   num_burn_in = 250, 
                   num_trees = 20,
                   seed = 100)



set.seed(100)
dB <- bart(x.train = iris2[,1:4],
           y.train = iris2[,5],
           ntree = 20,
           keeptrees = TRUE,
           nskip = 250,
           ndpost = 1000
)

```

## Create dataframe of trees

```{r extract_trees}
bmDF <- extractTreeData(model = bm, data = iris2)
dbDF <- extractTreeData(model = dB, data = iris2)
```

# Visualisations for Iris example:

## Figure 2:
```{r fig2}
vimpPlot(bmDF, plotType = 'point', metric = 'median')
```

## Figure 3:
```{r figs3}

# plot standard heatmap
myMatStd <- viviBartMatrix(bmDF,
                           type = 'standard',
                           metric = 'propMean', reorder = T)

viviBartPlot(myMatStd, impLims = c(0, 0.45))

# plot vsup
myMat <- viviBartMatrix(bmDF,
                        type = 'vsup',
                        metric = 'propMean',
                        metricError = "CV", reorder = T) 


viviBartPlot(myMat,
             impLims = c(0,0.45),
             label = 'CV')
```

## Figure 4:
```{r fig4_alltrees}
# plot all trees
plotAllTrees(bmDF, treeNo = 20)
```


## figure 5:
```{r figs5_selection_of_trees}

# finding iteration with lowest residual sd
bmPost <- bartMachine::bart_machine_get_posterior(bm, iris2[,1:4])

resid = NULL
for(i in 1:1000){
  resid[[i]] <- iris2[,5] - bmPost$y_hat_posterior_samples[,i]
}

finalRes <- lapply(resid, sd)
lowestRes <- which.min(finalRes)

# plot trees from selected iteration
plotAllTrees(bmDF, iter = lowestRes, sizeNode = T, fillBy = 'mu')
plotAllTrees(bmDF, iter = lowestRes, sizeNode = T, fillBy = 'response')
plotAllTrees(bmDF, iter = lowestRes, cluster = "depth")
plotAllTrees(bmDF, iter = lowestRes, cluster = "var")

```

## Figure 6:
```{r fig6_treebarplot}
# tree barplot
treeBarPlot(treeData = bmDF, topTrees = 10)
```


## Figure 7:
```{r fig7_mds}
# first get target proximity matrix
bmProx <- proximityMatrix(bmDF, iris2, reorder = T, normalize = T, iter = 736)
# plot MDS  (as this is interactive and is plotted in the 'Viewer' window, 
# it will not display in markdown)
mdsBart(treeData = bmDF, data = iris2, target =  bmProx,
        plotType = 'interactive', showGroup = F)
```

## Figure 8:
```{r fig8}
# acceptance rate (setting limits to be equal)
acceptRate(treeData = bmDF) + ylim(c(0, 1))
acceptRate(treeData = dbDF) + ylim(c(0, 1))
```

## Figure 9:
```{r fig9}
# tree depth per iteration (setting limits to be equal)
treeDepth(bmDF) + ylim(c(0.7, 1.6))
treeDepth(dbDF) + ylim(c(0.7, 1.6))

# tree nodes per iteration (setting limits to be equal)
treeNodes(bmDF) + ylim(c(2.3, 4.3))
treeNodes(dbDF) + ylim(c(2.3, 4.3))
```

## Figure 10:
```{r fig10}
# split density
splitDensity(treeData = bmDF, data = iris2, display = 'dataSplit')
splitDensity(dbDF, data = iris2, display = 'dataSplit')
```






