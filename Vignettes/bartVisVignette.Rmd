---
title: "bartMan"
author: "Alan Inglis"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
fig_width: 6 
fig_height: 4 
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Introduction
This vignette shows a quick example of how to use the current functions. to begin we create some data from the Friedman benchmark problem No 1.

```{r}
## Create some data
f <- function(x) {
  10 * sin(pi * x[, 1] * x[, 2]) + 20 * (x[, 3] - 0.5)^2 +
    10 * x[, 4] + 5 * x[, 5]
}

set.seed(1701)
sigma <- 1.0
n <- 200
x <- matrix(runif(n * 10), n, 10)
colnames(x) <- paste0("x", 1:10)
Ey <- f(x)
y <- rnorm(n, Ey, sigma)
fData <- as.data.frame(cbind(x, y))

x <- fData[, 1:10]
y <- fData$y

```

Now we will create some basic BART models. To begin we load the libraries and then create our models.

```{r, results =  'hide'}
# load libraries
library(BART)
library(dbarts)
library(bartMachine)
library(bartMan)
library(gridExtra) # for plots

# create BART model:
set.seed(99)
bartModel <- wbart(x.train = x,
                   y.train = y,
                   nskip = 100,
                   ndpost = 500,
                   nkeeptreedraws = 500,
                   ntree = 20
                   )

# create dbarts model:
set.seed(99)
dbartModel <- bart(x,
                   y,
                   ntree = 20,
                   keeptrees = TRUE,
                   nskip = 100,
                   ndpost = 500
                   )


# create bartMachine model (smaller to save time)
set.seed(90)
bartMachineModel <-  bartMachine(X = x,
                   y = y,
                   num_trees = 20,
                   flush_indices_to_save_RAM = FALSE,
                   num_burn_in = 50,
                   num_iterations_after_burn_in = 100)

```


Now we create a list of tree attributes, containing the tree structure for all the trees and additional information of the model. We extract the tree data for each model.

```{r}
# Create data frames ------------------------------------------------------
btT <- extractTreeData(bartModel) 
dbT <- extractTreeData(dbartModel) 
bmT <- extractTreeData(bartMachineModel) 
```


Taking a look at at the structure for the BART model:
```{r}
btT
```


* Diagnostic Plots

To view the acceptance rate of the trees, we use the `acceptanceRate` function. This function has an additional argument to select the burn-in.
```{r}
# acceptance rate
acceptRate(treeData = btT, burnIn = 100) # BART
```

Additionally, we can also view the tree depth per iterration and the average number of nodes per iteration:
```{r}
# tree depth per iteration
td <- treeDepth(treeData = btT, burnIn = 100) # BART
# tree nodes per iteration
tn <- treeNodes(treeData = btT, burnIn = 100)

grid.arrange(td, tn, ncol=2)
```


The `splitDensity` function shows the frequency of split values:
```{r}
splitDensity(btT)
```


proximity matrix:
NEED TO ADD THIS!!!

Finally, for a more complete diagnostic, we can use:

```{r}
bartDiag(model = bartModel, response = y, burnIn = 100)
```



## Tree Based Plots

To plot an individual tree, we can choose to display it either in dendrogram format, or icicle format. Additionally, we can choose which tree number or iteration to display:
```{r}
dend <- plotTree(btT, treeNo = 1, iter = 1, plotType = "dendrogram")
ice  <- plotTree(btT, treeNo = 1, iter = 1, plotType = "icicle")

#grid.arrange(dend, ice, ncol=2)
```

The `plotAllTrees` allows for a few different options when plotting. To begin, if no iteration or tree number is defined, we automatically plot all the trees from the final iteration:
```{r}
plotAllTrees(btT) # final iteration
```

We can also choose which tree number to display. For example, if we pick tree number 1, we display that tree over all iterations:
```{r}
plotAllTrees(btT, treeNo = 1) # final iteration
```

Additionally, we can cluster the displayed trees by either the variable:
```{r}
plotAllTrees(btT, cluster = "var")
```

or by the depth of the trees:
```{r}
plotAllTrees(btT, cluster = "depth")
```


